# Design pattern decisions

- **Commit/Reveal**: Implemented to ensure fair play, as users can only verify their encrypted moves after submitting them. Comes at the cost of users having to remember what their original moves were.
- **Game Expiration**: Implemented to ensure payouts always occurred, even for abandoned games or sore losers. For the MVP, I have yet to implement Ethereum Alarm Clock to trigger game expirations. The temporary hacked-together solution is to run an expiration check modifier function if any action is attempted on an in-progress game. In the event only one person revealed by the expiration time, they would have to resubmit their reveal in order to claim victory.
- **State Machine**: I used an enum to indicate what state a game was in, to determine what functions can be called on it.
- **"Fail Early and Fail Loud"**: I used require() statements wherever possible, as the first execution in the function logic.
- **Restricting Access**: I was very selective with what state variables are publicly readable, and what functions are publicly callable, and put checks in place to ensure the appropriate addresses (the players) are the only ones who can call functions on the games they're playing. I intentionally made player in-game wallet balances public as a temporary solution to help me update the state on the front end more easily. 
- **Owner-only Functions**: I opted out of creating a selfdestruct function because I want users to trust that I won't run away with their in-escrow wagers. I didn't even want to implement a circuitBreaker function but it's a requirement for this assignment. Yes, currently the app can be paused while games are ongoing, which could force those games to expire without users being able to take action.
- **Contract Simplicity and Readability**: I opted into writing a single contract, as opposed to separating the modifiers and function calls into separate contracts, because IMO the contract is still manageable to read. If it got any longer I'd certainly split it up into multiple inherited contracts for easier auditability.
- **Circuit Breaker**: The function owner can pause all action on the contract in case of an emergency. There is a situation here where games will still expire, thus possibly causing someone to lose an ongoing game.
- **"Balance withdrawal" pattern**: To protect users from DoS attacks from malicious contracts, I've implemented this pattern to separate ether transfer logic from game logic.
- **Events**: I use event listeners on the front end as a way to trigger UI value/state refreshing.


### Additional Notes

- **Game Incentives / UX Design**: I wrestled with the friction involved with having users (especially game creators) take multiple actions. I played with the thought of allowing challengers to auto-reveal their move upon joining a game, which is a great experience for the challenger (1 MetaMask action), but a disincentivized experience for the game creator, who would not only have to create the game, reveal their move within 24 hours of being challenged (whenever that is), and remember what their original move and password for that game was. This is very inconvenient and risky for game creators. So, I opted to simply have both creator and challenger go through the act of revealing their moves after being matched up, and in the future if I implement the "auto-reveal" feature for challengers I mentioned above, I would have the game pay out a small portion of the prize to the game creator if they happen to lose in order to incentivize game creation. If you have opinions on this, please share them with me!
